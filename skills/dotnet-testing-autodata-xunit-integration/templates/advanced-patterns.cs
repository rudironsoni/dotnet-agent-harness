// AutoData Advanced Patterns and CollectionSizeAttribute Examples
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using AutoFixture;
using AutoFixture.Kernel;
using AutoFixture.Xunit2;
using FluentAssertions;
using Xunit;

namespace AutoDataXunitIntegration.Templates;

// Test models
public class Product
{
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public bool IsAvailable { get; set; }
}

public class Customer
{
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty;
    public decimal CreditLimit { get; set; }

    public bool CanPlaceOrder(decimal orderAmount) => orderAmount <= CreditLimit;
}

public class Order
{
    public string OrderNumber { get; set; } = string.Empty;
    public decimal Amount { get; set; }
}

// CollectionSize attribute
public class CollectionSizeAttribute : CustomizeAttribute
{
    private readonly int _size;

    public CollectionSizeAttribute(int size)
    {
        _size = size;
    }

    public override ICustomization GetCustomization(ParameterInfo parameter)
    {
        ArgumentNullException.ThrowIfNull(parameter);

        var objectType = parameter.ParameterType.GetGenericArguments()[0];
        var isTypeCompatible = parameter.ParameterType.IsGenericType &&
            parameter.ParameterType.GetGenericTypeDefinition()
                .MakeGenericType(objectType)
                .IsAssignableFrom(typeof(List<>).MakeGenericType(objectType));

        if (!isTypeCompatible)
        {
            throw new InvalidOperationException(
                $"{nameof(CollectionSizeAttribute)} specified type is not compatible with List: " +
                $"{parameter.ParameterType} {parameter.Name}");
        }

        var customizationType = typeof(CollectionSizeCustomization<>).MakeGenericType(objectType);
        return (ICustomization)Activator.CreateInstance(customizationType, parameter, _size)!;
    }

    private class CollectionSizeCustomization<T> : ICustomization
    {
        private readonly ParameterInfo _parameter;
        private readonly int _repeatCount;

        public CollectionSizeCustomization(ParameterInfo parameter, int repeatCount)
        {
            _parameter = parameter;
            _repeatCount = repeatCount;
        }

        public void Customize(IFixture fixture)
        {
            fixture.Customizations.Add(new FilteringSpecimenBuilder(
                new FixedBuilder(fixture.CreateMany<T>(_repeatCount).ToList()),
                new EqualRequestSpecification(_parameter)));
        }
    }
}

// CollectionSize tests
public class CollectionSizeTests
{
    [Theory]
    [AutoData]
    public void CollectionSize_ControlsAutoGeneratedCollectionSize(
        [CollectionSize(5)] List<Product> products,
        [CollectionSize(3)] List<Order> orders,
        Customer customer)
    {
        products.Should().HaveCount(5);
        orders.Should().HaveCount(3);
        customer.Should().NotBeNull();

        products.Should().AllSatisfy(product =>
        {
            product.Name.Should().NotBeNullOrEmpty();
            product.Price.Should().BeGreaterOrEqualTo(0);
        });

        orders.Should().AllSatisfy(order =>
        {
            order.OrderNumber.Should().NotBeNullOrEmpty();
        });
    }

    [Theory]
    [AutoData]
    public void CollectionSize_MultipleDifferentSizes(
        [CollectionSize(1)] List<Customer> singleCustomer,
        [CollectionSize(10)] List<Product> manyProducts,
        [CollectionSize(2)] List<Order> twoOrders)
    {
        singleCustomer.Should().HaveCount(1);
        manyProducts.Should().HaveCount(10);
        twoOrders.Should().HaveCount(2);
    }

    [Theory]
    [AutoData]
    public void CollectionSize_LargeDataTest([CollectionSize(100)] List<Product> products)
    {
        products.Should().HaveCount(100);
        var distinctNames = products.Select(p => p.Name).Distinct().Count();
        distinctNames.Should().BeGreaterThan(1);
    }
}

// Hierarchical data organization
namespace DataSources
{
    public abstract class BaseTestData
    {
        protected static string GetTestDataPath(string fileName) =>
            Path.Combine(Directory.GetCurrentDirectory(), "TestData", fileName);
    }

    public class ProductTestDataSource : BaseTestData
    {
        public static IEnumerable<object[]> BasicProducts()
        {
            yield return new object[] { "iPhone", 35900m, true };
            yield return new object[] { "MacBook", 89900m, true };
            yield return new object[] { "AirPods", 7490m, false };
        }

        public static IEnumerable<object[]> ElectronicsProducts()
        {
            yield return new object[] { "Phone", "MOBILE", 35000m };
            yield return new object[] { "Laptop", "LAPTOP", 80000m };
            yield return new object[] { "Tablet", "TABLET", 25000m };
        }

        public static IEnumerable<object[]> DiscountedProducts()
        {
            yield return new object[] { "Clearance A", 1000m, 0.5m };
            yield return new object[] { "Clearance B", 2000m, 0.3m };
            yield return new object[] { "Seasonal", 3000m, 0.2m };
        }
    }

    public class CustomerTestDataSource : BaseTestData
    {
        public static IEnumerable<object[]> VipCustomers()
        {
            yield return new object[] { "Alice", "VIP", 100000m };
            yield return new object[] { "Bob", "VIP", 150000m };
        }

        public static IEnumerable<object[]> AllCustomerTypes()
        {
            yield return new object[] { "VIP", 100000m, 0.15m };
            yield return new object[] { "Premium", 50000m, 0.10m };
            yield return new object[] { "Regular", 20000m, 0.05m };
        }
    }
}

// Reusable data sets
public static class ReusableTestDataSets
{
    public static class ProductCategories
    {
        public static IEnumerable<object[]> All()
        {
            yield return new object[] { "Electronics", "TECH" };
            yield return new object[] { "Fashion", "FASHION" };
            yield return new object[] { "Home", "HOME" };
            yield return new object[] { "Sports", "SPORTS" };
        }

        public static IEnumerable<object[]> Electronics()
        {
            yield return new object[] { "Phone", "MOBILE" };
            yield return new object[] { "Laptop", "LAPTOP" };
            yield return new object[] { "Tablet", "TABLET" };
        }
    }

    public static class CustomerTypes
    {
        public static IEnumerable<object[]> All()
        {
            yield return new object[] { "VIP", 100000m, 0.15m };
            yield return new object[] { "Premium", 50000m, 0.10m };
            yield return new object[] { "Regular", 20000m, 0.05m };
        }
    }

    public static class OrderTransitions
    {
        public static IEnumerable<object[]> ValidTransitions()
        {
            yield return new object[] { "Created", "Confirmed" };
            yield return new object[] { "Confirmed", "Shipped" };
            yield return new object[] { "Shipped", "Delivered" };
            yield return new object[] { "Delivered", "Completed" };
        }
    }
}

// Tests using reusable data sets
public class ReusableDataSetTests
{
    public static IEnumerable<object[]> AllProductCategories() =>
        ReusableTestDataSets.ProductCategories.All();

    public static IEnumerable<object[]> AllCustomerTypes() =>
        ReusableTestDataSets.CustomerTypes.All();

    [Theory]
    [MemberAutoData(nameof(AllProductCategories))]
    public void ProductCategoryTest(string categoryName, string categoryCode, Product product)
    {
        categoryName.Should().NotBeNullOrEmpty();
        categoryCode.Should().NotBeNullOrEmpty();
        product.Should().NotBeNull();
        categoryName.Should().BeOneOf("Electronics", "Fashion", "Home", "Sports");
    }

    [Theory]
    [MemberAutoData(nameof(AllCustomerTypes))]
    public void CustomerTypeDiscountTest(string customerType, decimal creditLimit, decimal discountRate, Order order)
    {
        var customer = new Customer
        {
            Type = customerType,
            CreditLimit = creditLimit
        };

        customerType.Should().BeOneOf("VIP", "Premium", "Regular");
        creditLimit.Should().BePositive();
        discountRate.Should().BeInRange(0.05m, 0.15m);
        order.Should().NotBeNull();
    }
}

// Advanced assertions integration
public class AwesomeAssertionsIntegrationTests
{
    [Theory]
    [InlineAutoData("VIP", 100000)]
    [InlineAutoData("Premium", 50000)]
    [InlineAutoData("Regular", 20000)]
    public void ComplexValidation_CustomerOrderProcessing(
        string customerType,
        decimal creditLimit,
        [Range(1000, 15000)] decimal orderAmount,
        [CollectionSize(3)] List<Product> products,
        Customer customer,
        Order order)
    {
        customer.Type = customerType;
        customer.CreditLimit = creditLimit;
        order.Amount = orderAmount;

        var canPlaceOrder = customer.CanPlaceOrder(order.Amount);
        var discountRate = CalculateDiscount(customer.Type);

        customer.Type.Should().Be(customerType);
        customer.CreditLimit.Should().Be(creditLimit);
        order.Amount.Should().BeInRange(1000m, 15000m);
        canPlaceOrder.Should().BeTrue("Order amount should be within credit limit");
        discountRate.Should().BeInRange(0.05m, 0.15m);

        products.Should().HaveCount(3);
        products.Should().AllSatisfy(p => { p.Name.Should().NotBeNullOrEmpty(); });
    }

    private static decimal CalculateDiscount(string customerType) => customerType switch
    {
        "VIP" => 0.15m,
        "Premium" => 0.10m,
        "Regular" => 0.05m,
        _ => 0m
    };
}

// Performance tests
public class PerformanceTestDataTests
{
    [Theory]
    [AutoData]
    public void PerformanceTest_LargeProductProcessing([CollectionSize(1000)] List<Product> products)
    {
        var availableProducts = products.Where(p => p.IsAvailable).ToList();
        var totalValue = products.Sum(p => p.Price);
        var averagePrice = products.Average(p => p.Price);

        products.Should().HaveCount(1000);
        totalValue.Should().BePositive();
        averagePrice.Should().BePositive();
    }
}
