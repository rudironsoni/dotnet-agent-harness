# Complex Object Comparison: Advanced Comparison Pattern Detailed Examples

> This document is extracted from SKILL.md `## Core Usage Scenarios` and contains complete code examples for dynamic field exclusion, nested object exclusion, performance optimization, and order comparison.

## 3. Dynamic Field Exclusion

### 3.1 Excluding Timestamps and Auto-Generated Fields

```csharp
[Fact]
public void Entity_ExcludeAutoFields_ShouldValidateBusinessFields()
{
    var originalEntity = new UserEntity
    {
        Id = 1,
        Name = "John Doe",
        Email = "john@example.com",
        CreatedAt = DateTime.Now.AddDays(-1),
        UpdatedAt = DateTime.Now.AddDays(-1),
        Version = 1
    };

    var updatedEntity = userService.UpdateUser(1, new UpdateUserRequest 
    { 
        Name = "John Doe",
        Email = "john@example.com" 
    });

    // Exclude auto-updated fields
    updatedEntity.Should().BeEquivalentTo(originalEntity, options =>
        options.Excluding(e => e.UpdatedAt)
               .Excluding(e => e.Version)
               .Excluding(e => e.LastModifiedBy)
    );

    // Validate dynamic fields separately
    updatedEntity.UpdatedAt.Should().BeAfter(originalEntity.UpdatedAt);
    updatedEntity.Version.Should().Be(originalEntity.Version + 1);
}
```

### 3.2 Using Smart Exclusion Extension Methods

```csharp
// Define reusable exclusion strategies
public static class SmartExclusionExtensions
{
    public static EquivalencyOptions<T> ExcludingAutoGeneratedFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.EndsWith("Id") && 
                            ctx.SelectedMemberInfo.Name.StartsWith("Generated"))
            .Excluding(ctx => ctx.Path.EndsWith("At"))
            .Excluding(ctx => ctx.Path.EndsWith("Time"))
            .Excluding(ctx => ctx.Path.Contains("Version"))
            .Excluding(ctx => ctx.Path.Contains("Timestamp"));
    }

    public static EquivalencyOptions<T> ExcludingAuditFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.Contains("CreatedBy"))
            .Excluding(ctx => ctx.Path.Contains("CreatedAt"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedBy"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedAt"));
    }
}

[Fact]
public void Entity_UseSmartExclusion_ShouldSimplifyTests()
{
    var user = userService.CreateUser("test@example.com");
    var retrievedUser = userService.GetUser(user.Id);

    // Use smart exclusion extension methods
    retrievedUser.Should().BeEquivalentTo(user, options =>
        options.ExcludingAutoGeneratedFields()
               .ExcludingAuditFields()
    );
}
```

## 4. Nested Object Field Exclusion

```csharp
[Fact]
public void ComplexEntity_ExcludeNestedTimestamps_ShouldWork()
{
    var order = new Order
    {
        Id = 1,
        CustomerName = "John Doe",
        CreatedAt = DateTime.Now,
        Items = new[]
        {
            new OrderItem 
            { 
                Id = 1, 
                ProductName = "Laptop",
                AddedAt = DateTime.Now 
            }
        },
        AuditInfo = new AuditInfo
        {
            CreatedBy = "system",
            CreatedAt = DateTime.Now
        }
    };

    var retrievedOrder = orderService.GetOrder(1);

    // Use path pattern to exclude all timestamps
    retrievedOrder.Should().BeEquivalentTo(order, options =>
        options.Excluding(ctx => ctx.Path.EndsWith("At"))
               .Excluding(ctx => ctx.Path.EndsWith("Time"))
    );
}
```

## 5. Large Dataset Comparison Performance Optimization

### 5.1 Selective Property Comparison

```csharp
[Fact]
public void LargeDataSet_SelectiveComparison_ShouldExecuteEfficiently()
{
    var largeDataset = Enumerable.Range(1, 100000)
        .Select(i => new DataRecord 
        { 
            Id = i, 
            Value = $"Record_{i}",
            Timestamp = DateTime.Now 
        })
        .ToList();

    var processed = dataProcessor.Process(largeDataset);

    // Only compare key properties, ignore non-critical fields
    processed.Should().BeEquivalentTo(largeDataset, options =>
        options.Including(x => x.Id)
               .Including(x => x.Value)
               .Excluding(x => x.Timestamp)
    );
}
```

### 5.2 Sampling Validation Strategy

```csharp
[Fact]
public void LargeCollection_SamplingValidation_ShouldBalancePerformanceAndAccuracy()
{
    var largeDataset = GenerateLargeDataSet(100000);
    var processed = service.ProcessLargeDataset(largeDataset);

    // Validate count
    processed.Should().HaveCount(largeDataset.Count);

    // Sampling validation
    var sampleSize = Math.Min(1000, processed.Count / 10);
    var sampleIndices = Enumerable.Range(0, sampleSize)
        .Select(i => Random.Shared.Next(processed.Count))
        .Distinct()
        .ToList();

    foreach (var index in sampleIndices)
    {
        processed[index].Should().BeEquivalentTo(largeDataset[index], options =>
            options.ExcludingAutoGeneratedFields()
        );
    }

    // Statistical validation
    processed.Count(r => r.IsProcessed).Should().Be(processed.Count);
}
```

### 5.3 Key Property Fast Comparison

```csharp
public static class PerformanceOptimizedAssertions
{
    public static void AssertKeyPropertiesOnly<T>(
        T actual, 
        T expected, 
        params Expression<Func<T, object>>[] keySelectors)
    {
        foreach (var selector in keySelectors)
        {
            var actualValue = selector.Compile()(actual);
            var expectedValue = selector.Compile()(expected);
            actualValue.Should().Be(expectedValue, 
                $"Key property {selector} should match");
        }
    }
}

[Fact]
public void Order_KeyPropertyValidation_ShouldCompleteQuickly()
{
    var expected = new Order 
    { 
        Id = 1, 
        CustomerName = "John",
        TotalAmount = 999.99m,
        CreatedAt = DateTime.Now 
    };

    var actual = orderService.GetOrder(1);

    // Only compare key properties, ignore timestamps
    PerformanceOptimizedAssertions.AssertKeyPropertiesOnly(
        actual, 
        expected,
        o => o.Id,
        o => o.CustomerName,
        o => o.TotalAmount
    );
}
```

## 6. Strict Order vs Loose Comparison

```csharp
[Fact]
public void Collection_OrderControl_ShouldMeetRequirements()
{
    var expected = new[] { "A", "B", "C" };
    var actualStrict = service.GetOrderedList();
    var actualLoose = service.GetUnorderedList();

    // Strict order comparison
    actualStrict.Should().BeEquivalentTo(expected, options =>
        options.WithStrictOrdering()
    );

    // Loose comparison (order not considered)
    actualLoose.Should().BeEquivalentTo(expected, options =>
        options.WithoutStrictOrdering()
    );
}
```
