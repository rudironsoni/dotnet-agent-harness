using AwesomeAssertions;
using AwesomeAssertions.Primitives;
using System.Linq.Expressions;

namespace YourProject.Tests.CustomAssertions;

/// <summary>
/// Custom Assertions Extension Template
/// For creating domain-specific assertion methods to improve test readability and maintainability
/// </summary>
///
#region Domain-Specific Assertions - E-commerce Example

/// <summary>
/// E-commerce domain custom assertions
/// </summary>
public static class ECommerceAssertions
{
    /// <summary>
    /// Verify product is valid
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidProduct(
        this ObjectAssertions assertions,
        string because = "",
        params object[] becauseArgs)
    {
        var product = assertions.Subject as Product;

        product.Should().NotBeNull("Expected a Product object, but found {0}", assertions.Subject?.GetType());

        product!.Id.Should().BeGreaterThan(0, "Product ID must be greater than 0");
        product.Name.Should().NotBeNullOrEmpty("Product name cannot be null or empty");
        product.Price.Should().BeGreaterThan(0, "Product price must be greater than 0");

        return new AndConstraint<ObjectAssertions>(assertions);
    }

    /// <summary>
    /// Verify order is valid
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidOrder(
        this ObjectAssertions assertions,
        string because = "",
        params object[] becauseArgs)
    {
        var order = assertions.Subject as Order;

        order.Should().NotBeNull("Expected an Order object");

        order!.Id.Should().BeGreaterThan(0, "Order ID must be greater than 0");
        order.Items.Should().NotBeNullOrEmpty("Order must contain at least one item");
        order.TotalAmount.Should().BeGreaterThan(0, "Order total amount must be greater than 0");
        order.Items.Should().AllSatisfy(item =>
        {
            item.Quantity.Should().BeGreaterThan(0, "Item quantity must be positive");
            item.Price.Should().BeGreaterThan(0, "Item price must be positive");
        });

        return new AndConstraint<ObjectAssertions>(assertions);
    }

    /// <summary>
    /// Verify shopping cart state
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidCart(
        this ObjectAssertions assertions)
    {
        var cart = assertions.Subject as ShoppingCart;

        cart.Should().NotBeNull();
        cart!.Items.Should().NotBeNull("Cart items should not be null");
        cart.TotalItems.Should().Be(cart.Items.Count, "Total items count should match actual items");
        cart.TotalAmount.Should().Be(
            cart.Items.Sum(i => i.Price * i.Quantity),
            "Total amount should equal sum of all items");

        return new AndConstraint<ObjectAssertions>(assertions);
    }
}

#endregion

#region Smart Exclusion Extensions

/// <summary>
/// Smart field exclusion extensions
/// Automatically exclude common auto-generated fields and audit fields
/// </summary>
public static class SmartExclusionExtensions
{
    /// <summary>
    /// Exclude auto-generated fields (ID, timestamps, version numbers, etc.)
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAutoGeneratedFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.EndsWith("Id") &&
                            ctx.SelectedMemberInfo.Name.StartsWith("Generated"))
            .Excluding(ctx => ctx.Path.EndsWith("At"))
            .Excluding(ctx => ctx.Path.EndsWith("Time"))
            .Excluding(ctx => ctx.Path.Contains("Version"))
            .Excluding(ctx => ctx.Path.Contains("RowVersion"))
            .Excluding(ctx => ctx.Path.Contains("Timestamp"));
    }

    /// <summary>
    /// Exclude audit fields (CreatedBy, CreatedAt, ModifiedBy, ModifiedAt, etc.)
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAuditFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.Contains("CreatedBy"))
            .Excluding(ctx => ctx.Path.Contains("CreatedAt"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedBy"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedAt"))
            .Excluding(ctx => ctx.Path.Contains("LastModified"))
            .Excluding(ctx => ctx.Path.Contains("LastUpdated"));
    }

    /// <summary>
    /// Exclude all time-related fields
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAllTimeFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTime))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTimeOffset))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTime?))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTimeOffset?));
    }

    /// <summary>
    /// Combined: Exclude all common auto fields
    /// </summary>
    public static EquivalencyOptions<T> ExcludingCommonAutoFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .ExcludingAutoGeneratedFields()
            .ExcludingAuditFields();
    }
}

#endregion

#region Performance Optimized Assertions

/// <summary>
/// Performance optimized assertions extensions
/// For handling large data scenarios
/// </summary>
public static class PerformanceOptimizedAssertions
{
    /// <summary>
    /// Fast validation for large datasets
    /// Uses sampling strategy instead of full comparison
    /// </summary>
    public static void AssertLargeDataSet<T>(
        IEnumerable<T> actual,
        IEnumerable<T> expected,
        int sampleSize = 1000)
    {
        var actualList = actual.ToList();
        var expectedList = expected.ToList();

        // Quick count check
        actualList.Should().HaveCount(expectedList.Count);

        // Sampling validation
        var totalCount = actualList.Count;
        var actualSampleSize = Math.Min(sampleSize, totalCount);

        var sampleIndices = Enumerable.Range(0, actualSampleSize)
            .Select(i => Random.Shared.Next(totalCount))
            .Distinct()
            .ToList();

        foreach (var index in sampleIndices)
        {
            actualList[index].Should().BeEquivalentTo(expectedList[index]);
        }
    }

    /// <summary>
    /// Only verify key properties for performance
    /// </summary>
    public static void AssertKeyPropertiesOnly<T>(
        T actual,
        T expected,
        params Expression<Func<T, object>>[] keySelectors)
    {
        foreach (var selector in keySelectors)
        {
            var actualValue = selector.Compile()(actual);
            var expectedValue = selector.Compile()(expected);

            actualValue.Should().Be(expectedValue,
                $"Key property {selector} should match");
        }
    }
}

#endregion

#region Conditional Assertions

/// <summary>
/// Conditional assertions builder
/// Execute different validation logic based on conditions
/// </summary>
public static class ConditionalAssertions
{
    public static ConditionalAssertion<T> When<T>(this T subject, bool condition)
    {
        return new ConditionalAssertion<T>(subject, condition);
    }
}

public class ConditionalAssertion<T>
{
    private readonly T _subject;
    private readonly bool _condition;

    public ConditionalAssertion(T subject, bool condition)
    {
        _subject = subject;
        _condition = condition;
    }

    public AndConstraint<ObjectAssertions> Then(Action<T> assertion)
    {
        if (_condition)
        {
            assertion(_subject);
        }

        return new AndConstraint<ObjectAssertions>(_subject.Should());
    }
}

#endregion

#region Usage Examples

/// <summary>
/// Custom assertions usage examples
/// </summary>
public class CustomAssertionsUsageExamples
{
    [Fact]
    public void UseCase_DomainSpecificAssertions()
    {
        var product = new Product
        {
            Id = 1,
            Name = "Laptop",
            Price = 999.99m
        };

        // Use custom domain-specific assertion
        product.Should().BeValidProduct();
    }

    [Fact]
    public void UseCase_SmartExclusions()
    {
        var user = new User
        {
            Id = 1,
            Name = "John",
            Email = "john@example.com",
            CreatedAt = DateTime.Now,
            UpdatedAt = DateTime.Now,
            RowVersion = new byte[] { 1, 2, 3 }
        };

        var retrieved = new User
        {
            Id = 1,
            Name = "John",
            Email = "john@example.com",
            CreatedAt = DateTime.Now.AddDays(-1),  // Different
            UpdatedAt = DateTime.Now.AddHours(-2),  // Different
            RowVersion = new byte[] { 4, 5, 6 }     // Different
        };

        // Use smart exclusion extensions
        retrieved.Should().BeEquivalentTo(user, options => options
            .ExcludingCommonAutoFields()
        );
    }

    [Fact]
    public void UseCase_PerformanceOptimization()
    {
        var largeDataset = Enumerable.Range(1, 100000)
            .Select(i => new DataRecord { Id = i, Value = $"Record_{i}" })
            .ToList();

        var processed = largeDataset.Select(r => r).ToList();

        // Use performance-optimized validation strategy
        PerformanceOptimizedAssertions.AssertLargeDataSet(
            processed,
            largeDataset,
            sampleSize: 1000
        );
    }

    [Fact]
    public void UseCase_ConditionalAssertions()
    {
        bool isAdmin = true;
        var user = new User
        {
            Id = 1,
            Name = "Admin",
            Email = "admin@example.com"
        };

        // Execute different validation based on condition
        user.When(isAdmin)
            .Then(u => u.Name.Should().StartWith("Admin"));

        user.When(!isAdmin)
            .Then(u => u.Name.Should().NotStartWith("Admin"));
    }
}

#endregion

#region Test Model Classes

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public string CustomerName { get; set; } = string.Empty;
    public List<OrderItem> Items { get; set; } = new();
    public decimal TotalAmount { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class OrderItem
{
    public int ProductId { get; set; }
    public string ProductName { get; set; } = string.Empty;
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public class ShoppingCart
{
    public int Id { get; set; }
    public List<OrderItem> Items { get; set; } = new();
    public int TotalItems => Items.Count;
    public decimal TotalAmount => Items.Sum(i => i.Price * i.Quantity);
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public byte[]? RowVersion { get; set; }
}

public class DataRecord
{
    public int Id { get; set; }
    public string Value { get; set; } = string.Empty;
}

#endregion
